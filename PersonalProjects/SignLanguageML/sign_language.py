# -*- coding: utf-8 -*-
"""Sign language.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18vjoLKbZgQWu7_2_3Z24IXCdz1qzlCGC
"""

import numpy as np
import pandas as pd

import os

import torch
import matplotlib.pyplot as plt
from torch.autograd import Variable
import torchvision.transforms as transforms
import torch.nn as nn 
from sklearn.model_selection import train_test_split
import warnings
import string
import torch.nn.functional as F

from google.colab import files
uploaded = files .upload()

import io

train = pd.read_csv(io.BytesIO(uploaded['sign_mnist_train.csv']), sep = ",")#Takes in the data

from google.colab import files
uploaded = files .upload()

import io

test = pd.read_csv(io.BytesIO(uploaded['sign_mnist_test.csv']), sep = ",")#Takes in the data

labelstrain = train['label']
train.drop('label', axis=1, inplace=True)
labelstest = test['label']
test.drop('label', axis=1, inplace=True)

datatrain = train.values
labelstrain = labelstrain.values
testdata = test.values
labelstest = labelstest.values

def reshape_to_2d(data, dim):
    reshaped = []
    for i in data:
        reshaped.append(i.reshape(1, dim, dim))

    return np.array(reshaped)

datatrain = reshape_to_2d(datatrain, 28)

x = torch.FloatTensor(datatrain)
y = torch.LongTensor(labelstrain.tolist())

test_labels = torch.LongTensor(labelstest.tolist())

test_data_formated = reshape_to_2d(testdata, 28)
test_data_formated = torch.FloatTensor(test_data_formated)

epochs = 50
batch_size = 100
learning_rate = 0.001

class CNNModel(nn.Module): 
    
    def __init__(self):
        super(CNNModel, self).__init__()
        self.conv1 = nn.Conv2d(1, 10, 3)
        self.pool1 = nn.MaxPool2d(2)
        
        self.conv2 = nn.Conv2d(10, 20, 3)
        self.pool2 = nn.MaxPool2d(2)
        
        self.conv3 = nn.Conv2d(20, 30, 3) 
        self.dropout1 = nn.Dropout2d()
        
        self.fc3 = nn.Linear(30 * 3 * 3, 270) 
        self.fc4 = nn.Linear(270, 26) 
        
        self.softmax = nn.LogSoftmax(dim=1)
    
    
    def forward(self, x):
        x = self.conv1(x)
        x = F.relu(x)
        x = self.pool1(x)
        
        x = self.conv2(x)
        x = F.relu(x)
        x = self.pool2(x)
        
        x = self.conv3(x)
        x = F.relu(x)
        x = self.dropout1(x)
                
        x = x.view(-1, 30 * 3 * 3) 
        x = F.relu(self.fc3(x))
        x = F.relu(self.fc4(x))
        
        return self.softmax(x)
      
    def accuracy(self, predictions, labels):
        
        self.eval()
        correct = 0
        for pre, lab in zip(predictions, labels):
            if pre == lab:
                correct += 1
        
        acc = correct / len(predictions)
        print("Accuracy: %5f" % (acc))
    
    def precision(self, predictions, labels): 
      
        self.eval()  
        tp = 0
        fp = 0
        for pre, lab in zip(predictions, labels):
            if(pre == 0 and lab == 0):
              tp += 1
              
            if(pre == 0 and lab != 0) :
              fp += 1;
                
        prec = tp / (tp + fp)
        print("Precision: %5f" % (prec))
    #0=a,1=b,2=c,3=d ...  
    def recall(self, predictions, labels):
      
        self.eval()  
        tp = 0
        fn = 0
        for pre, lab in zip(predictions, labels):
            if(pre == 0 and lab == 0):#0 represents a
              tp += 1
              
            if(pre != 0 and lab == 0) :
              fn += 1;
     
        rec = tp / (tp + fn)
        print("Recall: %5f" % (rec))
    
    
model = CNNModel()

optimizer = torch.optim.SGD(model.parameters(), learning_rate, momentum=0.7)
loss_func = nn.CrossEntropyLoss()

loss_log = []

for e in range(epochs):
    for i in range(0, x.shape[0], batch_size):
        x_mini = x[i:i + batch_size] 
        y_mini = y[i:i + batch_size] 
        
        optimizer.zero_grad()
        model_out = model(Variable(x_mini))
        
        loss = loss_func(model_out, Variable(y_mini))
        loss.backward()
        optimizer.step()
        
        if i % 1000 == 0:
            loss_log.append(loss.item())
    if(e % 5 == 0 or e == 50):
      print('Epoch: {} - Loss: {:.6f}'.format(e + 1, loss.item()))
      predictions = model(Variable(test_data_formated))
      model.accuracy(torch.max(predictions.data, 1)[1], test_labels)
      model.precision(torch.max(predictions.data, 1)[1], test_labels)
      model.recall(torch.max(predictions.data, 1)[1], test_labels)
      print(\n)